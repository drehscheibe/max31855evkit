// SPDX-License-Identifier: GPL-2.0
/*
 * Show type-K thermocouple temperature from a max31855evkit
 *
 * Copyright (c) 2018 Melchior FRANZ <mfranz@aon.at>
 */
#include <linux/hidraw.h>
#include <linux/input.h>
#include <linux/types.h>

#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include <endian.h>
#include <errno.h>
#include <getopt.h>
#include <math.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define DEFAULT_FORMAT "%t\t%.2F\t%E\n"  // adapt help screen if you change this


// raw data format that the max31855 chip sends via SPI
struct max31855_data_t {
	int16_t open_circuit_error : 1;
	int16_t ground_short_error : 1;
	int16_t supply_short_error : 1;
	int16_t reserved2 : 1;
	int16_t cold_junction_temp : 12;
	int16_t fault : 1;
	int16_t reserved1 : 1;
	int16_t raw_temp : 14;
};


// sensor data and cooked values generated by process()
struct temp_data_t {
	union {
		struct max31855_data_t data;
		uint32_t set;
	} u;
	unsigned counter;
	time_t local_time_offset; // [s]
	double raw_temp;
	double cold_junction_temp;
	double temp;
	double temp_min;
	double temp_max;
	double temp_filtered;
	double filter_coeff;
};


static enum {
	NORMAL,
	INFO,
	DEBUG,
} verbose = NORMAL;


static bool aborted;
static bool reset_min_max;


static void help()
{
	printf("Usage: max31855evkit [-v] [-q] [-d <device>] [-c <filter-coeff>] [-f <format>] [-n <number>] [-i <interval>]\n");
	printf("       max31855evkit [-h]\n");
	printf("\n");
	printf("  -c, --coeff      lowpass (EMWA) filter coefficient (default: 0.1, i.e. 10%% of new plus 90%% of old value; see format %%F)\n");
	printf("  -d, --device     device file (default: /dev/sensor/DS3900_Module_HIDClass)\n");
	printf("  -f, --format     print data in this format (default: \"%%t\\t%%.2F\t%%E\\n\")\n");
	printf("  -h, --help       this help screen\n");
	printf("  -i, --interval   interval in milliseconds (default: 1000)\n");
	printf("  -n, --number     number of cycles (default: 0, i.e. infinity)\n");
	printf("  -q, --quiet      reset verbosity\n");
	printf("  -v, --verbose    verbose (up to two times: -vv)\n");
	printf("\n");
	printf("FORMAT:\n");
	printf("   %%C              cold junction temperature (MAX31855 chip tmperature ~= ambient temperature)\n");
	printf("   %%R              \"hot\" junction raw temperature as reported by the max31855 (must be linearized)\n");
	printf("   %%T              linearized \"real\" temperature considering type-K sensor properties\n");
	printf("   %%F              low-pass filtered linearized temperature (see option --coeff)\n");
	printf("   %%I              minimum filtered linearized temperature (reset by sending SIGUSR1)\n");
	printf("   %%A              maximum filtered linearized temperature (reset by sending SIGUSR1)\n");
	printf("   %%E              error string\n");
	printf("   %%t              Unix epoch plus local time offset (for gnuplot; use %%{%%s}t for UTC epoch)\n");
	printf("   %%{<fmt>}t       date/time in given strftime() format; example %%{%%Y}t for the year\n");
	printf("   %%n              counter, starting with 0\n");
	printf("   %%d              degree sign and uppper-case C\n");
	printf("   %%%%              percent sign\n");
	printf("\n");
	printf("   \\n, \\t ...      newline, tabulator, etc. as usual (see man ASCII)\n");
	printf("\n");
	printf("To get the default device link automatically generated, add this to your udev rules:\n");
	printf("SUBSYSTEM==\"hidraw\", ACTION==\"add\", ATTRS{idVendor}==\"04fa\", ATTRS{idProduct}==\"3900\", MODE:=\"660\", GROUP:=\"plugdev\", IMPORT{builtin}=\"usb_id\", SYMLINK+=\"sensor/%%E{ID_MODEL}\"\n");
	printf("then call 'udevadm control --reload-rules' and re-plug the device\n");
	printf("\n");
}


static void fatal(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	exit(EXIT_FAILURE);
}


static int print(FILE *stream, const char *f, const struct temp_data_t *t)
{
	int ret, count = 0;

	while (*f) {
		if (*f == '\\') {
			if (!*++f)
				break;

			char c = *f++;
			if (c == 'a')
				c = '\a';
			else if (c == 'b')
				c = '\b';
			else if (c == 'f')
				c = '\f';
			else if (c == 'n')
				c = '\n';
			else if (c == 'r')
				c = '\r';
			else if (c == 't')
				c = '\t';
			else if (c == 'v')
				c = '\v';

			putc(c, stream);
			count++;

		} else if (*f == '%') {
			const double *val = NULL;

			if (!*++f)
				break;

			// read sud-format
			char sub[128], *b = sub;
			if (*f == '{') {
				for (f++; *f && *f != '}' && b < sub + sizeof(sub) - 1; )
					*b++ = *f++;
				if (*f++ != '}') {
					fprintf(stderr, "error: %s: sub-format incomplete\n", __func__);
					return -1;
				}
			}
			*b = '\0';

			// read precision (along with %lf, because we don't need it for other letters, anyway)
			static const char mod[] = "0123456789+-. ";
			char fmt[128];
			b = fmt;
			*b++ = '%';
			for (; *f && strchr(mod, *f) && b < fmt + sizeof(fmt) - 3; )
				*b++ = *f++;
			if (!*f) {
				fprintf(stderr, "error: %s: precision statement incomplete\n", __func__);
				return -2;
			}
			*b = '\0';

			if (verbose >= DEBUG)
				fprintf(stream, "\033[90m<<%s|%s|%c>>\033[m", sub, fmt, *f);

			if (*f == '%') {
				putc(*f, stream);
				count++;

			} else if (*f == 'd') {
				fputs("\xb0" "C", stream); // degree celsius
				count++;

			} else if (*f == 'n') {
				*b++ = 'u';
				*b = '\0';
				ret = fprintf(stream, fmt, t->counter);
				if (ret < 0)
					; // error
				else
					count += ret;

			} else if (*f == 't') {
				time_t epoch = time(NULL);
				if (epoch == -1) {
					fprintf(stderr, "error: %s: time(): %m\n", __func__);
					return -3;
				}

				if (*sub) {
					struct tm *st = localtime(&epoch);
					ret = strftime(fmt, sizeof(fmt), sub, st);
					if (ret < 0)
						perror("strftime");
					ret = fprintf(stream, fmt);
					if (ret < 0)
						;
					count += ret;

				}  else {
					epoch += t->local_time_offset;
					ret = fprintf(stream, "%lld", (long long)epoch);
					if (ret < 0)
						fprintf(stderr, "fprintf(): %d\n", ret);
					else
						count += ret;
				}

			} else if (*f == 'C') {
				val = &t->cold_junction_temp;

			} else if (*f == 'R') {
				val = &t->raw_temp;

			} else if (*f == 'T') {
				val = &t->temp;

			} else if (*f == 'F') {
				val = &t->temp_filtered;

			} else if (*f == 'I') {
				val = &t->temp_min;

			} else if (*f == 'A') {
				val = &t->temp_max;

			} else if (*f == 'e') {
				const struct max31855_data_t *m = &t->u.data;
				if (m->fault) // will always be on if any of the following three is
					printf("fault: ");
				if (m->open_circuit_error)
					printf("open-circuit ");
				if (m->ground_short_error)
					printf("ground-short ");
				if (m->supply_short_error)
					printf("supply-short ");
			}

			if (val) {
				*b++ = 'l';
				*b++ = 'f';
				*b = '\0';

				ret = fprintf(stream, fmt, *val);
				if (ret < 0)
					fprintf(stderr, "fprintf(): %d\n", ret);
				else
					count += ret;
			}
			f++;

		} else {
			putc(*f++, stream);
			count++;
		}
	}
	fflush(stream);
	return count;
}


static void process(struct temp_data_t *t)
{
	struct max31855_data_t *d = &t->u.data;
	double raw = t->raw_temp = d->raw_temp / 4.0;
	double cold = t->cold_junction_temp = d->cold_junction_temp / 16.0;

	// linearization according to "MAX31855-Linearized-Thermocouple-Temperature.pdf"
	// with parameters desribed in https://srdata.nist.gov/its90/download/type_k.tab

	double delta = raw - cold; // [degC]
	double tc_voltage = delta * 0.041276; // [mV] thermocouple voltage
	double e = tc_voltage; // [mV] cold junction equivalent thermocouple voltage

	if (cold < 0.0) {
		// E = sum(i=0 to n) c_i t^i.
		const static double a[] = { // -270 .. 0 degC
			0.000000000000E+00, 0.394501280250E-01, 0.236223735980E-04, -0.328589067840E-06,
			-0.499048287770E-08, -0.675090591730E-10, -0.574103274280E-12, -0.310888728940E-14,
			-0.104516093650E-16, -0.198892668780E-19, -0.163226974860E-22,
		};

		for (int i = 0; i < ARRAY_SIZE(a); i++)
			e += a[i] * pow(cold, i);

	} else {
		// E = sum(i=0 to n) c_i t^i + a0 exp(a1 (t - a2)^2).
		const static double a[] = { // 0 .. 1372 degC
			-0.176004136860E-01, 0.389212049750E-01, 0.185587700320E-04, -0.994575928740E-07,
			0.318409457190E-09, -0.560728448890E-12, 0.560750590590E-15, -0.320207200030E-18,
			0.971511471520E-22, -0.121047212750E-25,
		};

		const static double c[] = {
			0.118597600000E+00,
			-0.118343200000E-03,
			0.126968600000E+03,
		};

		for (int i = 0; i < ARRAY_SIZE(a); i++)
			e += a[i] * pow(cold, i);

		e += c[0] * exp(c[1] * (cold - c[2]) * (cold - c[2]));
	}

	if (e < -5.891 || e > 54.886) {
		//fprintf(stderr, "invalid cold junction equivalent thermocouple voltage %lf\n", e);
		e = NAN;
	}

	static const double inverse_coeff[3][10] = {
		{
			0.0000000E+00, 2.5173462E+01, -1.1662878E+00, -1.0833638E+00, -8.9773540E-01,
			-3.7342377E-01, -8.6632643E-02, -1.0450598E-02, -5.1920577E-04, 0.0000000E+00,
		}, {
			0.000000E+00, 2.508355E+01, 7.860106E-02, -2.503131E-01, 8.315270E-02,
			-1.228034E-02, 9.804036E-04, -4.413030E-05, 1.057734E-06, -1.052755E-08,
		}, {
			-1.318058E+02, 4.830222E+01, -1.646031E+00, 5.464731E-02, -9.650715E-04,
			8.802193E-06, -3.110810E-08, 0.000000E+00, 0.000000E+00, 0.000000E+00,
		}
	};

	const double *b;
	if (e < 0.0) {
		b = inverse_coeff[0];
	} else if (e < 20.644) {
		b = inverse_coeff[1];
	} else {
		b = inverse_coeff[2];
	}

	double temp = b[0];
	for (int i = 1; i < ARRAY_SIZE(inverse_coeff[0]); i++)
		temp += b[i] * pow(e, i);

	t->temp = temp;

	if (isnan(t->temp_filtered))
		t->temp_filtered = temp;
	else
		t->temp_filtered = temp * t->filter_coeff + t->temp_filtered * (1.0 - t->filter_coeff);

	// we are taking min/max from the filtered temperature so that artifact spikes don't ruin them as much
	if (t->temp_filtered < t->temp_min)
		t->temp_min = t->temp_filtered;
	if (t->temp_filtered > t->temp_max)
		t->temp_max = t->temp_filtered;
}


static time_t local_time_offset()
{
	char z[6];
	time_t epoch = time(NULL);
	struct tm *st = localtime(&epoch);
	strftime(z, sizeof(z), "%z", st);
	return (((z[1] - '0') * 10 + z[2] - '0') * 60 + (z[3] - '0') * 10 + z[4] - '0') * (z[0] == '-' ? -60 : 60);
}


static int hidwrite(int fd, void *data, size_t len)
{
	static uint8_t buf[32] = { 0 };
	strncpy(buf, (uint8_t *)data, len);

	int ret = write(fd, buf, 32);
	if (ret < 0) {
		printf("Error: %d\n", errno);
		perror("write");
		return -1;
	} else if (verbose >= DEBUG) {
		printf("\033[35m> %2d bytes: \t", ret);
		for (int i = 0; i < ret; i++)
			printf("%02x ", buf[i]);
		printf("\033[m\n");
		return 0;
	}
}


static int hidread(int fd, uint32_t *d)
{
	static uint8_t buf[32];
	int ret = read(fd, buf, 32);
	if (ret < 0) {
		perror("read");

	} else {
		if (verbose >= DEBUG) {
			printf("\033[36m< %2d bytes:\t", ret);
			for (int i = 0; i < ret; i++)
				printf("%02x ", buf[i]);
			printf("\033[m\n");
		}
		if (d)
			*d = be32toh(*(uint32_t *)buf);
	}
}


static void irq_handler(int sig)
{
	if (sig == SIGUSR1)
		reset_min_max = true;
	else
		aborted = true;
}


int main(int argc, char **argv)
{
	int fd;
	const char *device = "/dev/sensor/DS3900_Module_HIDClass";
	long number = -1;
	unsigned long interval = 1000 * 1000; // [us]
	char *p, *format = DEFAULT_FORMAT;
	struct temp_data_t t = {
		.temp_min = +INFINITY,
		.temp_max = -INFINITY,
		.filter_coeff = 0.1,
		.temp_filtered = NAN,
		.local_time_offset = local_time_offset(),
	};

	while (1) {
		int c;
		int option_index = 0;

		static const struct option long_options[] = {
			{ "device",      required_argument, 0, 'd' },
			{ "format",      required_argument, 0, 'f' },
			{ "help",        no_argument,       0, 'h' },
			{ "interval",    required_argument, 0, 'i' },
			{ "lowpass",     required_argument, 0, 'l' },
			{ "number",      required_argument, 0, 'n' },
			{ "quiet",       no_argument,       0, 'q' },
			{ "verbose",     no_argument,       0, 'v' },
			{ 0,             0,                 0,  0  }
		};

		c = getopt_long(argc, argv, "d:f:hi:n:qv", long_options, &option_index);
		if (c == -1)
			break;

		switch (c) {
		case 'c':
			
			break;

		case 'd':
			device = optarg;
			break;

		case 'f':
			format = optarg;
			break;

		case 'h':
			help();
			exit(0);
			break;

		case 'i':
			interval = (long)strtoul(optarg, &p, 10) * 1000;
			if (!p || *p || interval < 0)
				fatal("bad argument to -i\n");
			break;

		case 'l':
			// lowpass filter coefficient
			break;

		case 'n':
			number = strtoul(optarg, &p, 10);
			if (!p || *p)
				fatal("bad argument to -n\n");
			break;

		case 'q':
			verbose = 0;
			break;

		case 'v':
			verbose++;
			break;

		case '?':
			break;

		default:
			printf("?? getopt returned character code 0%o ??\n", c);
		}
	}

	while (optind < argc)
		fprintf(stderr, "don't know what to do with %s\n", argv[optind++]);

	struct sigaction sa;
	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = irq_handler;
	sigaction(SIGINT, &sa, NULL);   // Ctrl-c
	sigaction(SIGQUIT, &sa, NULL);  // Ctrl-\  (prevent segfault)
	sigaction(SIGUSR1, &sa, NULL);

#if 0
	fd = open(device, O_RDWR | O_NONBLOCK);
	if (fd < 0) {
		perror("Unable to open device");
		return 1;
	}

	// the values are taken from the kernel's usbmon output
	hidwrite(fd, "\xc2", 1);
	usleep(100000);
	hidread(fd, NULL);

	hidwrite(fd, "\xc0", 1);
	usleep(100000);
	hidread(fd, NULL);

	hidwrite(fd, "\xf3", 1);
	usleep(100000);
	hidread(fd, NULL);

	hidwrite(fd, "\xc6\x03", 2);
	usleep(100000);
	hidread(fd, NULL);

	hidwrite(fd, "\xeb", 1);
	usleep(100000);
	hidread(fd, NULL);

	hidwrite(fd, "\xf6\x01", 2);
	usleep(100000);
	hidread(fd, NULL);

	hidwrite(fd, "\xfa", 1);
	usleep(100000);
	hidread(fd, NULL);

	hidwrite(fd, "\x30\x02", 2);
	usleep(100000);
	hidread(fd, NULL);
#endif

	while (!aborted) {
#if 0
		hidwrite(fd, "\xf6\x01", 2);
		usleep(10000);
		hidread(fd, NULL);

		hidwrite(fd, "\xf6\x00", 2);
		usleep(10000);
		hidread(fd, NULL);

		// this was a changing value in the usbmon log, but this works, too
		hidwrite(fd, "\x31\x04\x80\xef\x12", 5);
		usleep(10000);
		hidread(fd, &t.u.set);
#else
		if (reset_min_max) {
			t.temp_min = +INFINITY;
			t.temp_max = -INFINITY;
			reset_min_max = false;
		}

		t.u.set = 0x01741a30;
		process(&t);
		if (print(stdout, format, &t) < 0)
			number = 1;
		t.counter++;
#endif

#if 0
		hidwrite(fd, "\xf6\x01", 2);
		usleep(10000);
		hidread(fd, NULL);
#endif

		if (number > 0 && !--number)
			break;

		usleep(interval - 40000);
	}

	if (aborted)
		putc('\n', stdout);
	close(fd);
	return 0;
}
